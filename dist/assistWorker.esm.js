const e="WORKER_MESSAGE",n="JOB_RESULT",s=e=>e instanceof ArrayBuffer||e instanceof MessagePort||self.ImageBitmap&&e instanceof ImageBitmap,t=()=>{const t=[];let o,r=new Map;const a={collect:e=>{for(let n in e)r.set(n,e[n]);return a},onMessage:e=>(o=e,a),create:a=>{const c=a.toString(),i=`\n        // 将收集到的变量声明和定义加入脚本字符串，后面函数执行的时候便不会出现not defined的错误了\n        $collections = {};\n        ${Object.entries(Object.fromEntries(r)).reduce(((e,[n,s])=>e+(`$collections['${n}']=`+("function"==typeof s?`${s};`:`JSON.parse(\`${JSON.stringify(s)}\`);`))),"")}\n  \n        // 声明定义用于判断是否是可转移对象的函数\n        $isTransferables = ${s}\n  \n        // 在脚本中声明并定义一个包含工作流程的函数体\n        $job=${c};\n  \n        // 给worker线程添加消息监听，等待主线程的发号施令\n        onmessage=e=>{\n          const { index, args } = e.data;\n  \n          Promise.resolve(\n            $job.apply($job, args.concat([{\n              collections: $collections,\n              postMessage: (message) => postMessage({ type: '${e}', message }),\n              close: self.close,\n            }]))\n          ).then(result => {\n            postMessage({ type: '${n}', message: { index, result } }, [result].filter($isTransferables))\n          }).catch(error => {\n            postMessage({ type: '${n}', message: { index, error } })\n          })\n        }\n      `,l=URL.createObjectURL(new Blob([i],{type:"text/javascript"})),g=new Worker(l);g.onmessage=function(s){const r=s.data;if(r.type===e&&o&&o.call(o,r.message),r.type===n){const{index:e,result:n,error:s}=r.message,{done:o}=t[e];o(s,n)}};return{run:(...e)=>new Promise(((n,o)=>{const r=t.length;t.push({done:(e,s)=>{e?o(e):n(s)}}),g.postMessage({index:r,args:e},e.filter(s))})),terminate:()=>{g.terminate(),URL.revokeObjectURL(l),t.length=0,r.clear(),o=void 0}}}};return a};export{t as createAssistWorker};
//# sourceMappingURL=assistWorker.esm.js.map
