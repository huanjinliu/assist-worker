!function(e,n){e&&!e.getElementById("livereloadscript")&&((n=e.createElement("script")).async=1,n.src="//"+(self.location.host||"localhost").split(":")[0]+":35730/livereload.js?snipver=1",n.id="livereloadscript",e.getElementsByTagName("head")[0].appendChild(n))}(self.document),function(){"use strict";const e="WORKER_MESSAGE",n="JOB_RESULT",s=e=>e instanceof ArrayBuffer||e instanceof MessagePort||self.ImageBitmap&&e instanceof ImageBitmap;!async function(){const t=(()=>{const t=[];let o,r=new Map;const a={collect:e=>{for(let n in e)r.set(n,e[n]);return a},onMessage:e=>(o=e,a),create:a=>{const c=a.toString(),l=`\n        // 将收集到的变量声明和定义加入脚本字符串，后面函数执行的时候便不会出现not defined的错误了\n        $collections = {};\n        ${Object.entries(Object.fromEntries(r)).reduce(((e,[n,s])=>e+`$collections['${n}']=`+("function"==typeof s?`${s};`:`JSON.parse(\`${JSON.stringify(s)}\`);`)),"")}\n  \n        // 声明定义用于判断是否是可转移对象的函数\n        $isTransferables = ${s}\n  \n        // 在脚本中声明并定义一个包含工作流程的函数体\n        $job=${c};\n  \n        // 给worker线程添加消息监听，等待主线程的发号施令\n        onmessage=e=>{\n          const { index, args } = e.data;\n  \n          Promise.resolve(\n            $job.apply($job, args.concat([{\n              collections: $collections,\n              postMessage: (message) => postMessage({ type: '${e}', message }),\n              close: self.close,\n            }]))\n          ).then(result => {\n            postMessage({ type: '${n}', message: { index, result } }, [result].filter($isTransferables))\n          }).catch(error => {\n            postMessage({ type: '${n}', message: { index, error } })\n          })\n        }\n      `,i=URL.createObjectURL(new Blob([l],{type:"text/javascript"})),g=new Worker(i);return g.onmessage=function(s){const r=s.data;if(r.type===e&&o&&o.call(o,r.message),r.type===n){const{index:e,result:n,error:s}=r.message,{done:o}=t[e];o(s,n)}},{run:(...e)=>new Promise(((n,o)=>{const r=t.length;t.push({done:(e,s)=>{e?o(e):n(s)}}),g.postMessage({index:r,args:e},e.filter(s))})),terminate:()=>{g.terminate(),URL.revokeObjectURL(i),t.length=0,r.clear(),o=void 0}}}};return a})().onMessage((e=>console.log(e))).collect({numbers:[0,1,0,2]}).create((async(e,{collections:n,postMessage:s,close:t})=>{const{numbers:o}=n;let r=e;for(let e=0,n=o.length;e<n;e++){const n=o[e];r+=n,0===n&&s({type:"zero-index",value:e})}return{type:"sum",value:r}}));console.log(await t.run(10))}()}();
